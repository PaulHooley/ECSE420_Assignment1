# ECSE 420: Assignment 1

### Paul Hooley 260727150, Albert Kragl 260732298

1.6) As you can see from the chart, when the matrix is of a smaller size the runtime of the sequential multiplication is faster than that of the parallel multiplication. This is likely from the overhead of having to create all the threads (Note that the optimum thread count that we found was 6) and manage them. However this problem quickly dissapears when the make the matricies larger as the matrix multiplication above 1000x1000 the runtime for the sequential multiplication was a factor larger than the parallel version.

2.1) There are 4 conditions that could cause a deadlock, first is mutual exclusion, a process requires exclusive control of its resources. Second is the concept of hold and wait, where the process must hold its resources while waiting to get others. Third is no preemption, where much like hold and wait the process will not give up its resources until it is finished with it. Lastly, circular wait must be present so that each process in a chain holds the resources that the next one requires.

2.2) There are a few common strategies to deal with deadlocks. Since all 4 of the above conditions must be true for a deadlock to occur, all we have to do is ensure one of them is prevented. Firstly, we could disallow mutual exclusion. Secondly we could stop the hold and wait by blocking the process until all resources are available. We add preemption by forcing a process to release all resources that it's holding if it cannot get all that it needs, and then request at a later time. Lastly we can prevent circular wait by defining a linear ordering of resource types.

3.2) To avoid deadlock, we need to prevent one of the four necessary conditions that can allow deadlock to occur. In our approach, we disallow the circular wait condition by having one of the philosophers pick up the right chopstick first instead of the left one. In our implementation we made the first philosopherpick up their chopsticks in reverse order. This avoids the situation where each philosopher picks up the chopstick to their left, causing deadlock.

3.3) To avoid starvation, we modified our implementation from part 3.2 to use Semaphores instead of Objects for the chopsticks. One of the constructors for the Java Semaphore class accepts a `fair` boolean argument, which specifies if the Semaphore will guarantee FIFO granting of permits under contention. This way, each chopstick is granted in a fair way and the philosopher that has waited longest will be granted the chopstick, preventing starvation.

4.1) Given that the sequential part of the program accounts for 30% of the execution time, we know that `p = 0.7`. We can use the following equation to determine a limit for the overall speedup:

```
speedup <= 1 / (1 - p) = 1 / (1 - 0.7) = 3.33
```

Therefore the best possible speedup would be to make the program run 3.33 times faster.

4.2) We can express this problem as follows:

```
1 / ((0.4/k) + (0.6/n)) > 2 * (1 / (0.4 + (0.6/n)))
```

Then we can solve for `k`:

```
1 / ((0.4/k) + (0.6/n)) > 2 * (1 / (0.4 + (0.6/n)))
2((0.4/k) + (0.6/n)) < 0.4 + (0.6/n)
(0.8/k) + (1.2/n) < 0.4 + (0.6/n)
(0.6/n) - 0.4 < -(0.8/k)
-(0.6/n) - 0.4 > (0.8/k)
0.4 - (0.6/n) > (0.8/k)
k(0.4 - (0.6/n)) > 0.8
k > 0.8 / (0.4 - (0.6/n))
k > 2 - (4/3)n, n > 1
```

4.3) We can express the problem as follows:

```
1 / ((1-p)/4 + (p/n)) = 2 * (1 / (1-p + (p/n)))
```

We can then solve for `p`:

```
1 / 2((1-p)/4 + (p/n)) = (1 / (1-p + (p/n)))
2((1-p)/4 + (p/n)) = 1 - p + (p/n)
(1-p)/2 + 2(p/n) = 1 - p + (p/n)
(1-p)/2 = p / n
2 / n = (1 - p) / p = (1 / p) - 1
(1 / p) = (2 / n) + 1
p = n / (n + 2)
```

Lastly we can find the overall execution time of the sequential part by finding an expression for `1 - p`:

```
p = n / (n + 2)
1 - p = 1 - (n / (n + 2))
```
